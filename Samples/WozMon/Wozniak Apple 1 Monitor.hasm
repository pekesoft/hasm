// Wozniak Apple 1 Monitor

%Base FF00h	// Rom Start

//******* Hardware Variables ************

DSP   = $D012	// Video I/O
DSPCR = $D013

KBD   = $D010	// Keyboard I/O
KBDCR = $D011

//********* Zero Page Variables *********

XAML = $24
XAMH = $25
STL  = $26
STH  = $27
L    = $28
H    = $29
YSAV = $2A
MODE = $2B

//******** $200-$27F Text Buffer *********

IN = $0200

//******** Listing *************

RESET:          CLD             // Clear decimal arithmetic mode.
                CLI
                Y = 7Fh        // Mask for DSP data direction register
                (DSP) = Y         // Set it up.
                A = A7h        // KBD and DSP control register mask.
                (KBDCR) = A       // Enable interrupts, set CA1, CB1, for
                (DSPCR) = A       //  postitive edge sense/output mode.
NOTCR:          CMP #$DFh        // "<-"?
                BEQ BACKSPACE   // Yes.
                CMP #$9Bh        // ESC?
                BEQ ESCAPE      // Yes.
                Y++             // Advance text inX--.
                BPL NEXTCHAR    // Auto ESC if > 127.
ESCAPE:         A = DCh        // "\".
                JSR ECHO        // Output it.
GETLINE:        A = 8Dh        // CR.
                JSR ECHO        // Output it.
                Y = 01h        // Initiallize text inX--.
BACKSPACE:      Y--             // Backup text inX--.
                BMI GETLINE     // Beyond start of line, reinitialize
NEXTCHAR:       A = (KBDCR)       // Key ready?
                BPL NEXTCHAR    // Loop until ready.
                A = (KBD)         // Load character. B7 shoul be '1'
                (IN + Y) = A        // Add to text buffer.
                JSR ECHO        // Display character.
                CMP #$8D        // CR?
                BNE NOTCR       // No.
                Y = FF        // Reset text inX--.
                A = 00        // For XAM mode.
                TAX             // 0->X.
SETSTOR:        ASL A           // Leaves $7B if setting STOR mode.
SETMODE:        (MODE) = A        // $00 = XAM, $7B = STOR, $A3 = BLOK XAM
BLSKIP:         Y++             // Advance text inX--.
NEXTITEM:       A = (IN + Y)        // Get character.
                CMP #$8D        // CR?
                BEQ GETLINE     // Yes, done this line.
                CMP #$AE        // "."?
                BCC BLSKIP      // Skip delimiter.
                BEQ SETMODE     // Set BLOCK XAM mode.
                CMP #$BA        // ":"?
                BEQ SETSTOR     // Yes, set STOR mode.
                CMP #$D2        // "R"?
                BEQ RUN         // Yes, run user program.
                (L) = X           // $00->L.
                (H) = X           //  and H.
                (YSAV) = Y        // Save Y for comparison.
NEXTHEX:        A = (IN + Y)        // Get character for hex test.
                EOR #$B0        // Map digits to $0-9.
                CMP #$0A        // Digit?
                BCC DIG         // Yes.
                A += 88h + Carry        // Map letter "A"-"F" to $FA-FF.
                CMP #$FA        // Hex letter?
                BCC NOTHEX      // No, character not hex.
DIG:            ASL A
                ASL A           // Hex digit to MSD of A.
                ASL A           //
                ASL A           //
                X = 04h        // Shift count.
HEXSHIFT:       ASL A           // Hex digit left, MSDB to carry.
                ROL L           // Rotate into LSD.
                ROL H           // Rotate into MSD's.
                X--             // Done 4 shifts?
                BNE HEXSHIFT    // No, loop.
                Y++             // Advance text inX--.
                BNE NEXTHEX     // Always taken. Check next character for hex.
NOTHEX:         CPY YSAV        // Check if L, H empty (no hex digits)
                BEQ ESCAPE      // Yes, generate ESC sequence.
                BIT MODE        // Test MODE byte.
                BVC NOTSTOR     // B6 = 0 for STOR, 1 for XAM and BLOCK XAM
                A = (L)           // LSD's of hex data.
                ((STL + X)) = A     // Store at current 'store inX--'.
                INC STL         // Increment store inX--.
                BNE NEXTITEM    // Get next item. (no carry).
                INC STH         // Add carry to 'store inX--' high order.
TONEXTITEM:     JMP NEXTITEM    // Get next command item.
RUN:            JMP (XAML)      // Run at current XAM inX--.
NOTSTOR:        BMI XAMNEXT     // B7 = 0 for XAM, 1 for BLOCK XAM.
                X = 02        // Byte count.
SETADR:         A = (L-1 + X)       // Copy hex data to
                (STL-1 + X) = A     //  'store inX--'.
                (XAML-1 + X) = A    // And to 'XAM inX--'.
                X--             // Next of 2 bytes.
                BNE SETADR      // Loop unless X = 0.
NXTPRNT:        BNE PRDATA      // NE means no address to print.
                A = 8Dh        // CR.
                JSR ECHO        // Output it.
                A = (XAMH)        // 'Examine inX--' high-order byte.
                JSR PRBYTE      // Output it in hex format.
                A = (XAML)        // Low-order 'examine inX--' byte.
                JSR PRBYTE      // Output it in hex format.
                A = BAh        // ":".
                JSR ECHO        // Output it.
PRDATA:         A = A0h        // Blank.
                JSR ECHO        // Output it.
                A = ((XAML + X))    // Get data byte at 'examine inX--'
                JSR PRBYTE      // Output it in hex format.
XAMNEXT:        (MODE) = X        // 0->MODE (XAM mode).
                A = (XAML)
                CMP L           // Comapre 'examine inX--' to hex data.
                A = (XAMH)        // 
                A -= H + Carry
                BCS TONEXTITEM  // Not less, so no more data to output.
                INC XAML        // 
                BNE MOD8CHK     // Increment 'examine inX--'.
                INC XAMH        // 
MOD8CHK:        A = (XAML)        // Check low-order 'examine inX--' byte
                A &= 07h        //  For MOD 8=0
                BPL NXTPRNT     // Always taken.
PRBYTE:         PHA             // Save A for LSD.
                LSR A
                LSR A
                LSR A           // MSD to LSD position.
                LSR A
                JSR PRHEX       // Output hex digit.
                PLA             // Restore A.
PRHEX:          A &= 0Fh        // Make LSD for hex print.
                A |= B0h        // Add "0".
                CMP #$BA        // Digit?
                BCC ECHO        // Yes, output it.
                A += 06 + Carry        // Add offset for letter.
ECHO:           BIT DSP         // DA bit (B7) cleared yet?
                BMI ECHO        // No, wait for display
                (DSP) = A         // Output character. Sets DA.
                RTS             // Return.

.byte $0000
.byte $0F00                     // NMI
.byte $FF00                     // RESET
.byte $0000                     // IRQ